/*
@Author:        hogan.chen@ymail.com
@Create Date:   2020-11-11
*/

package main

import (
	"fmt"
	"time"
)

/*
布尔值：
%t    单词true或false

整数：
%b    表示为二进制
%c    该值对应的unicode码值
%d    表示为十进制
%o    表示为八进制
%q    该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示
%x    表示为十六进制，使用a-f
%X    表示为十六进制，使用A-F
%U    表示为Unicode格式：U+1234，等价于"U+%04X"

浮点数、复数的两个组分：
%b    无小数部分、二进制指数的科学计数法，如-123456p-78；参见strconv.FormatFloat %e    科学计数法，如-1234.456e+78 %E    科学计数法，如-1234.456E+78 %f    有小数部分但无指数部分，如123.456 %F    等价于%f %g    根据实际情况采用%e或%f格式（以获得更简洁、准确的输出）
%G    根据实际情况采用%E或%F格式（以获得更简洁、准确的输出）

字符串和[]byte：
%s    直接输出字符串或者[]byte %q    该值对应的双引号括起来的go语法字符串字面值，必要时会采用安全的转义表示
%x    每个字节用两字符十六进制数表示（使用a-f）
%X    每个字节用两字符十六进制数表示（使用A-F）

指针：
%p    表示为十六进制，并加上前导的0x

宽度通过一个紧跟在百分号后面的十进制数指定，如果未指定宽度，则表示值时除必需之外不作填充。精度通过（可能有的）宽度后跟点号后跟的十进制数指定。如果未指定精度，会使用默认精度；如果点号后没有跟数字，表示精度为0。举例如下：

%f:    默认宽度，默认精度
%9f    宽度9，默认精度
%.2f   默认宽度，精度2 %9.2f  宽度9，精度2 %9.f   宽度9，精度0

宽度和精度格式化控制的是Unicode码值的数量（不同于C的printf，它的这两个因数指的是字节的数量）。两者任一个或两个都可以使用'*'号取代，此时它们的值将被对应的参数（按'*'号和verb出现的顺序，即控制其值的参数会出现在要表示的值前面）控制，这个操作数必须是int类型。

对于大多数类型的值，宽度是输出的最小字符数，如果必要是会用空格填充。对于字符串，宽度是输出字符数目的最低数量，如果必要会截断字符串。

对于整数，宽度和精度都设置输出总长度。采用精度时表示右对齐并用0填充，而宽度默认表示用空格填充。

对于浮点数，宽度设置输出总长度；精度设置小数部分长度（如果有的话），除了%g/%G，此时精度设置总的数字个数。例如，对数字123.45，格式%6.2f 输出123.45；格式%.4g输出123.5。%e和%f的默认精度是6，%g的默认精度是可以将该值区分出来需要的最小数字个数。

对复数，宽度和精度会分别用于实部和虚部，结果用小括号包裹。因此%f用于1.2+3.4i输出(1.200000+3.400000i)。
*/
func fmtPrintf() {
	/*
	Go 的 fmt 相关的函数支持一些占位符，最常见的是字符串占位符的 %s，整型占位符 %d，以及浮点型占位符 %f。现在让我们探究一些其他的占位符。
	%v & %T
	%v 占位符可以打印任何 Go 的值，%T 可以打印出变量的类型。我经常使用这些占位符来调试程序。
	*/
	// 定义一个interface的变量i，该变量指向float类型
	var i interface{} = 3.1415926
	fmt.Printf("Type(e) = %T, e = %v\n", i, i)

	/*
	宽度
	你可以为一个打印的数值指定宽段，比如：

	fmt.Printf("%10d\n", 353)  // will print "       353"

	你还可以通过将宽度指定为 * 来将宽度当作 Printf 的参数，例如：

	fmt.Printf("%*d\n", 10, 353)  // will print "       353"

	当你打印出数字列表而且希望它们能够靠右对齐时，这非常的有用。
	*/
	fmt.Printf("%10[1]d, %010[1]d\n", 353)
	fmt.Printf("%*d, %0*d\n", 5, 353, 5, 353)
	fmt.Printf("%0*[2]d\n", 5, 353)
	fmt.Printf("%010d, %0*[3]d\n", 123, 5, 353)

	/*
	通过位置引用
	如果你在一个格式化的字符串中多次引用一个变量，你可以使用 %[n]，其中 n 是你的参数索引（位置，从 1 开始）。
	*/
	fmt.Printf("The price of %[1]s was $%[2]d. $%[2]d! imagine that.\n", "carrot", 23)

	/*
	%v
	%v 占位符将会打印出 Go 的值，如果此占位符以 + 作为前缀，将会打印出结构体的字段名，如果以 # 作为前缀，那么它会打印出结构体的字段名和类型。
	*/
	type Point struct {
		X int
		Y int
	}
	p := &Point{1, 2}
    fmt.Printf("%v %+v %#v \n", p, p, p)

	fmt.Printf("%[2]d %[1]d\n", 11, 22) //输出  22 11
	// 控制浮点数的打印，浮点数占6位（右对齐），小数部分占2位，所以输出为 12.00
	fmt.Printf("%[3]*.[2]*[1]f\n", 12.0, 2, 6) //输出  12.00
	fmt.Printf("%d %d %#[1]x %#x\n", 16, 17)  //输出   16 17 0x10 0x11
}

func main() {
	start := time.Now()
	fmt.Printf("Program start execution at %s\n\n", start.Format("2006-01-02 15:04:05"))

	fmtPrintf()

	elapsed := time.Since(start)
	fmt.Printf("\nProgram end execution at %s\n", time.Now().Format("2006-01-02 15:04:05"))
	fmt.Printf("Total elapsed time: %s\n", elapsed)
}
